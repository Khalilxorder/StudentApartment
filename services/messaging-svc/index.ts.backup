// Messaging Service - In-app communication system
// Handles messages between students and apartment owners

import { createClient } from '@/utils/supabaseClient';

export interface Message {
  id: string;
  conversationId: string;
  senderId: string;
  recipientId: string;
  content: string;
  type: 'text' | 'image' | 'document' | 'system';
  timestamp: Date;
  read: boolean;
  readAt?: Date;
}

export interface Conversation {
  id: string;
  participants: string[];
  apartmentId: string;
  lastMessage: Message;
  unreadCount: Map<string, number>; // userId -> count
  createdAt: Date;
  updatedAt: Date;
}

export interface MessageThread {
  conversation: Conversation;
  messages: Message[];
  participants: Array<{
    userId: string;
    name: string;
    avatar?: string;
    verified: boolean;
  }>;
}

export class MessagingService {
  async createConversation(
    initiatorId: string,
    recipientId: string,
    apartmentId: string,
    initialMessage: string
  ): Promise<string> {
    const participants = [initiatorId, recipientId];
    const conversationKey = this.buildConversationKey(apartmentId, participants);

    const existingConversation = await this.findExistingConversation(conversationKey);
    if (existingConversation) {
      await this.sendMessage(existingConversation.id, initiatorId, initialMessage);
      return existingConversation.id;
    }

    const conversationId = this.generateUuid();
    const storedMessage = await this.storeMessageRecord({
      conversationId,
      conversationKey,
      apartmentId,
      senderId: initiatorId,
      recipientId,
      content: initialMessage,
      type: 'text',
    });

    await this.notifyRecipient(storedMessage);
    return conversationId;
  }

  async sendMessage(
    conversationId: string,
    senderId: string,
    content: string,
    type: 'text' | 'image' | 'document' | 'system' = 'text'
  ): Promise<Message> {
    const conversation = await this.getConversation(conversationId);
    if (!conversation) {
      throw new Error('Conversation not found');
    }

    if (!conversation.participants.includes(senderId)) {
      throw new Error('User is not a participant in this conversation');
    }

    const recipientId = conversation.participants.find(id => id !== senderId);
    if (!recipientId) {
      throw new Error('Unable to resolve conversation recipient');
    }

    const storedMessage = await this.storeMessageRecord({
      conversationId,
      conversationKey: this.buildConversationKey(conversation.apartmentId, conversation.participants),
      apartmentId: conversation.apartmentId,
      senderId,
      recipientId,
      content,
      type,
    });

    conversation.lastMessage = storedMessage;
    conversation.updatedAt = storedMessage.timestamp;

    const currentUnread = conversation.unreadCount.get(recipientId) || 0;
    conversation.unreadCount.set(recipientId, currentUnread + 1);
    conversation.unreadCount.set(senderId, 0);

    await this.updateConversation(conversation);
    await this.notifyRecipient(storedMessage);

    return storedMessage;
  }

  async getConversationThread(conversationId: string, userId: string): Promise<MessageThread | null> {
    const conversation = await this.getConversation(conversationId);
    if (!conversation || !conversation.participants.includes(userId)) {
      return null;
    }

    const messages = await this.getMessages(conversationId);
    const participants = await this.getParticipants(conversation.participants);

    await this.markMessagesAsRead(conversationId, userId);

    return {
      conversation,
      messages,
      participants,
    };
  }

  async getUserConversations(userId: string): Promise<Conversation[]> {
    const conversations = await this.getUserConversationsFromDb(userId);
    return conversations.sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime());
  }

  async getUnreadCount(userId: string): Promise<number> {
    const conversations = await this.getUserConversations(userId);
    return conversations.reduce((total, conv) => total + (conv.unreadCount.get(userId) || 0), 0);
  }

  private async findExistingConversation(conversationKey: string): Promise<Conversation | null> {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('messages')
      .select('conversation_id')
      .eq('conversation_key', conversationKey)
      .order('created_at', { ascending: false })
      .limit(1);

    if (error || !data || data.length === 0) {
      return null;
    }

    return this.getConversation(data[0].conversation_id);
  }

  private async getConversation(conversationId: string): Promise<Conversation | null> {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('messages')
      .select('*')
      .eq('conversation_id', conversationId)
      .order('created_at', { ascending: true });

    if (error || !data || data.length === 0) {
      return null;
    }

    return this.hydrateConversation(conversationId, data);
  }

  private async getMessages(conversationId: string): Promise<Message[]> {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('messages')
      .select('*')
      .eq('conversation_id', conversationId)
      .order('created_at', { ascending: true });

    if (error || !data) {
      return [];
    }

    return data.map(row => this.mapRowToMessage(row));
  }

  private async storeMessageRecord(params: {
    conversationId: string;
    conversationKey: string;
    apartmentId: string;
    senderId: string;
    recipientId: string;
    content: string;
    type: Message['type'];
  }): Promise<Message> {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('messages')
      .insert({
        conversation_id: params.conversationId,
        conversation_key: params.conversationKey,
        apartment_id: params.apartmentId,
        sender_id: params.senderId,
        receiver_id: params.recipientId,
        content: params.content,
        read: false,
        read_at: null,
        updated_at: new Date().toISOString(),
      })
      .select('*')
      .single();

    if (error || !data) {
      console.error('Failed to store message:', error);
      throw error;
    }

    return this.mapRowToMessage(data);
  }

  private async getParticipants(userIds: string[]): Promise<Array<{
    userId: string;
    name: string;
    avatar?: string;
    verified: boolean;
  }>> {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('user_profiles')
      .select('id, full_name, avatar_url, verified')
      .in('id', userIds);

    if (error || !data) {
      return userIds.map(id => ({
        userId: id,
        name: `User ${id.slice(0, 8)}`,
        verified: false,
      }));
    }

    return data.map(profile => ({
      userId: profile.id,
      name: profile.full_name || `User ${profile.id.slice(0, 8)}`,
      avatar: profile.avatar_url || undefined,
      verified: profile.verified ?? false,
    }));
  }

  private async updateConversation(conversation: Conversation): Promise<void> {
    // Conversations are derived from message history; nothing to persist yet.
    console.log('Conversation updated:', conversation.id);
  }

  private async markMessagesAsRead(conversationId: string, userId: string): Promise<void> {
    const supabase = createClient();
    const { error } = await supabase
      .from('messages')
      .update({
        read: true,
        read_at: new Date().toISOString(),
      })
      .eq('conversation_id', conversationId)
      .eq('receiver_id', userId)
      .eq('read', false);

    if (error) {
      console.error('Failed to mark messages as read:', error);
    }
  }

  private async getUserConversationsFromDb(userId: string): Promise<Conversation[]> {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('messages')
      .select('*')
      .or(`sender_id.eq.${userId},receiver_id.eq.${userId}`);

    if (error || !data) {
      return [];
    }

    const grouped = new Map<string, any[]>();
    data.forEach(row => {
      const key = row.conversation_id;
      if (!key) {
        return;
      }
      if (!grouped.has(key)) {
        grouped.set(key, []);
      }
      grouped.get(key)!.push(row);
    });

    const conversations: Conversation[] = [];
    for (const [conversationId, rows] of grouped.entries()) {
      try {
        conversations.push(this.hydrateConversation(conversationId, rows));
      } catch (error) {
        console.error('Failed to hydrate conversation:', error);
      }
    }

    return conversations;
  }

  private async notifyRecipient(message: Message): Promise<void> {
    // Integrate with notification service (push/email) in future.
    console.log(`Notifying ${message.recipientId} about new message ${message.id}`);
  }

  private buildConversationKey(apartmentId: string, participants: string[]): string {
    const sorted = this.normalizeParticipants(participants);
    return [apartmentId, ...sorted].join('::');
  }

  private normalizeParticipants(participants: string[]): string[] {
    return Array.from(new Set(participants)).sort();
  }

  private generateUuid(): string {
    const globalCrypto =
      typeof globalThis !== 'undefined'
        ? (globalThis as { crypto?: { randomUUID?: () => string } }).crypto
        : undefined;

    if (globalCrypto && typeof globalCrypto.randomUUID === 'function') {
      return globalCrypto.randomUUID();
    }

    // Lightweight RFC4122 v4 fallback
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }

  private mapRowToMessage(row: any): Message {
    return {
      id: row.id,
      conversationId: row.conversation_id,
      senderId: row.sender_id,
      recipientId: row.receiver_id,
      content: row.content,
      type: 'text',
      timestamp: new Date(row.created_at),
      read: row.read,
      readAt: row.read_at ? new Date(row.read_at) : undefined,
    };
  }

  private hydrateConversation(conversationId: string, rows: any[]): Conversation {
    if (!rows || rows.length === 0) {
      throw new Error('Cannot hydrate conversation without messages');
    }

    const sortedRows = rows
      .slice()
      .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());

    const messages = sortedRows.map(row => this.mapRowToMessage(row));
    const participants = this.normalizeParticipants(
      sortedRows.flatMap(row => [row.sender_id, row.receiver_id])
    );

    const apartmentId = sortedRows[0].apartment_id;
    const lastMessage = messages[messages.length - 1];
    const unreadCount = new Map<string, number>();

    participants.forEach(participantId => {
      const count = messages.filter(msg => !msg.read && msg.recipientId === participantId).length;
      unreadCount.set(participantId, count);
    });

    return {
      id: conversationId,
      participants,
      apartmentId,
      lastMessage,
      unreadCount,
      createdAt: messages[0].timestamp,
      updatedAt: lastMessage.timestamp,
    };
  }
}

export const messagingService = new MessagingService();
